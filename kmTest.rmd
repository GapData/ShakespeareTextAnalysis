* create test input
```{r createTestInput, tidy = TRUE, fig.width = 10, fig.height = 8}
set.seed(3)
weights <- read.csv('output.csv', header=FALSE)
kmTestInput <- data.frame(x = runif(30, max = 5), y = runif(30, max = 5))
#write.csv(km$cluster, 'kmTestOutput.csv', row.names = FALSE, quote = FALSE)
#write.csv(kmInputTest, 'kmTestInput.csv', row.names = FALSE, quote= FALSE)
```
* compare different starting points
```{r compare, tidy = TRUE, fig.width = 12, fig.height = 8}
set.seed(1)
km1 <- kmeans(kmTestInput, 2)
set.seed(45)
km2 <- kmeans(kmTestInput, 2)
par(mfrow = c(1,2))
plot(kmTestInput, pch = km1$cluster, col = km1$cluster)
plot(kmTestInput, pch = km2$cluster, col = km2$cluster)
```
* sum of squares decomposition

```{r fun, tidy = TRUE} 
withinSS <- function(dat, km_object) {
    # dat = k-means input matrix/dataframe
    # km_object = object of class kmeans
    # returns total within group sum of squares

    dat$cluster <- km_object$cluster

    within_ss <- 0
    
    for(c in 1:length(unique(dat$cluster))) {
        s2c <- 0
        for(i in 1:ncol(dat[, names(dat) != 'cluster'])) {
            s2c <- s2c + sum((dat[ dat$cluster == c, i] - mean(dat[ dat$cluster == c, i]))^2)
        }
        within_ss <- within_ss + s2c 
    }
    return(within_ss)
}

betweenSS <- function(dat, km_object) {
    # dat = k-means input matrix/dataframe
    # km_object = object of class kmeans
    # returns between group sum of squares

    dat$cluster <- km_object$cluster

    between_ss <- 0
    
    for(c in 1:length(unique(dat$cluster))) {
        d <- 0
        for(i in 1:ncol(dat[, names(dat) != 'cluster'])) {
            d <- d + (mean(dat[ dat$cluster == c, i]) - mean(dat[,i]))^2
        }
        between_ss <- between_ss + (d*sum(dat$cluster == c))
    }
    return(between_ss)
}

explainedSS <- function(dat, km_object) {
    # dat = k-means input matrix/dataframe
    # km_object = object of class kmeans
    # returns total sum of squares

    100 * betweenSS(dat, km_object)/(betweenSS(dat, km_object) + withinSS(dat, km_object))
}

```
* variance explained
```{r varExplained, tidy = TRUE, fig.width = 10, fig.height = 8}
explainedSS(kmTestInput, km1)
100 * betweenSS(kmTestInput, km1)/(betweenSS(kmTestInput, km1) + withinSS(kmTestInput, km1)) # percentage of variance explained

var_explained <- numeric()

for(i in 1:10){
    km <- kmeans(kmTestInput, i)
    var_explained <- c(var_explained, 100 * km$betweenss/km$totss)
}

plot(var_explained) ## looks like 5 is optimal

plot(kmTestInput, col = kmeans(kmTestInput, 5)$cluster, pch = '+')
```

* using the shakespeares weights matrix
```{r shakespeare, fig.width = 10, fig.width = 8}
var_explained <- numeric()

for(i in 1:(nrow(weights)-1)) {
    km <- kmeans(weights, i)
    var_explained <- c(var_explained, 100 * km$betweenss/km$totss)
}

plot(var_explained)

require(skmeans)

var_explained <- numeric()

for(i in 2:20) {
    print(i)
    km <- skmeans(as.matrix(weights), i)
    var_explained <- c(var_explained, explainedSS(weights, km))
}

plot(var_explained)
``` 